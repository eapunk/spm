#!/usr/bin/env php
<?php
/**
 * @license http://hardsoft321.org/license/ GPLv3
 * @author Evgeny Pervushin <pea@lab321.ru>
 *
 * SugarCRM Package Manager
 */

define('SPM_VERSION', '1.7.1');

class SpmCmdHelp extends SpmCmd
{
    public function executeNonSugar()
    {
        echo <<<_USAGE_
Usage:
    spm help
    spm version
    spm list [<pattern>]
    spm install <id_name>[-<version>]
    spm uninstall <id_name>[-<version>]
    spm upload <id_name>[-<version>]
    spm remove <id_name>[-<version>]
    spm repair
    spm dbquery [<sql>]
    spm check
    spm file <file1> [<file2> ...]
    spm create
    spm zip <id_name>[-<version>]
    spm sandbox-init
    spm sandbox-status
    spm sandbox-install
    spm md5-generate [<filename>]
    spm md5-compare <file1> [<file2>]

spm help
    Display this help. Can be executed outside of the SugarCRM.

spm version
    Display version. Can be executed outside of the SugarCRM.

spm list [<pattern>]
    List packages. Has different behavior outside of the SugarCRM and inside it.
    By default, list installed packages and loaded but not installed packages
    optionally filtered by <pattern>. List available packages if -a option used.
    Available packages are folders with sources (not zipped) located at spm_path.
    spm_path can be specified by environment variable SPM_PATH or option --spm-path.
    Available packages can be used for uploading to SugarCRM or just zipping.
    Manifest file will be automatically extracted if only zip files was uploaded.
    Options:
        -a - list available packages
        --each-version - print one line for each version
        --spm-path=<path> - search package sources on <path>

spm install <id_name>[-<version>]
    Install package. The package must be loaded to SugarCRM. Manifest file will be
    automatically extracted if only zip file was uploaded.
    Options:
        --no-copy - do not execute install procedure; just run pre_install and post_install scripts
        --lock-file=<file> - file used to lock installation/uninstallation, .spm.lock, by default
        --log-file=<file> - file used to log installation/uninstallation, spm.log, by default

spm uninstall <id_name>[-<version>]
    Uninstall package. By default, if doesn't remove tables, ACL, etc.
    Options:
        --remove-tables - remove bean tables
        --remove-acl - remove ACL actions
        --remove-custom - remove customization directory
        --remove-prefs - remove user preferences
        --remove-relationships - remove relationships (and modify viewdefs)
        --not-uninstallable - uninstall package even if it hasn't is_uninstallable attribute
        --no-copy - do not execute uninstall procedure; just run pre_uninstall
        --lock-file=<file> - file used to lock installation/uninstallation, .spm.lock, by default
        --log-file=<file> - file used to log installation/uninstallation, spm.log, by default

spm upload <id_name>[-<version>]
    Zip sources and upload zip archive and manifest to the SugarCRM upload directory.
    Sources must be among the available packages (see `spm list`).
    Also php syntax checked for all php files.
    Options:
        --no-php-check - skip php syntax check
        --spm-path=<path> - search package sources on <path>

spm remove <id_name>[-<version>]
    Remove package files from upload directory.

spm repair
    Run Quick Repair and Rebuild. Show SQL-queries if differences found between database and vardefs.
    Options:
        -v - show output

spm dbquery [<sql>]
    Run SQL-query on SugarCRM database. If sql not specified, standard input will be read.
    If .spmqueries.php file exists, it must return an array of allowed queries.
    In this case error will be thrown if executed query is not in the list.
    Options:
        -s - skip unallowed queries, i.e. do not throw exception when the query is not allowed
        -f - force execution of any query even if file .spmqueries.php exists and it not contains the query

spm check
    Search conflicts between installed packages.
    Options:
        --by-restore - also run conflict search based on files saved in *-restore folders
        -a - do not hide conflicts that resolved by `overwrite` attribute
        --modified - search for files that was added or modified but not in packages

spm file <file1> [<file2> ...]
    Try to search file(s) in the installed packages.
    Options:
        --sync - write file back to its package
        --spm-path=<path> - search package sources on <path> in sync command

spm create
    Run interactive dialogue and then create folder with simple package structure.
    Can be executed outside of the SugarCRM.

spm zip <id_name>[-<version>]
    Create zip archive of package sources in the current directory.
    Can be executed outside of the SugarCRM.
    Sources must be among the available packages (see `spm list`).
    Options:
        --no-php-check - skip php syntax check
        --spm-path=<path> - search package sources on <path>

spm sandbox-init
    Create file .spmsandbox. After creating, this file should be manually edited
    to store information about which packages must be installed. While creating
    the file, all currently installed packages will be written to sandbox file
    commented by semicolon.
    Options:
        --no-merge - write to file not only last version of each package but every version installed earlier

spm sbinit
    This is an alias for `spm sandbox-init`.

spm sandbox-status [environment1 [environment2 ...]]
    Show difference between currently installed packages and sandbox file.
    Multiple environments separated by spaces may be depicted. By default,
    packages with empty environment used for building difference.
    Options:
        --file=<file> - path to sandbox file, use it to compare with other installation
        --input - use standard input instead of file

spm sbstatus
    This is an alias for `spm sandbox-status`.

spm sandbox-install [environment1 [environment2 ...]]
    Run installation of packages listed in `spm sandbox-status` (including reinstall section).
    Options:
        --file=<file> - path to sandbox file (if not default)
        --input - use standard input instead of file
        --no-uninstall - do not uninstall previous versions of installing packages
        + all options from `spm install` command
        + all options from `spm uninstall` command

spm sbinstall
    This is an alias for `spm sandbox-install`.

spm md5-generate [<filename>]
    Generate file with array of files md5 checksums. Format is like in Diagnostic Tool (MD5 Calculated array).
    If filename not specified, it will be generated.

spm md5-compare <file1> [<file2>]
    Compare arrays with md5 checksums. Files must contains checksums in format
    like in Diagnostic Tool (MD5 Calculated array) or like in file files.md5.
    If file2 not specified, current checksums array will be generated and used.


_USAGE_;
    }
}

class Spm
{
    /**
     * DB for storing per SugarCRM data
     */
    private $db;

    /**
     * DB for storing per user data (system account, not sugar)
     */
    private $userDb;

    /**
     * Directory where script was executed
     */
    public $cwd;

    public $spmPath;
    public $sandboxFile = '.spmsandbox';
    public $lockFile = '.spm.lock';
    public $logFile = 'spm.log';
    public $packagesOverwrites = array();
    public $packagesInStaging = array();
    public $packagesAvailable = array();

    /**
     * Simple method to find conflicts. Use it if `check` doesn't work.
     */
    public function listRestoreConflicts()
    {
        global $db;
        $q = "SELECT id_name, filename FROM upgrade_history WHERE status = 'installed'";
        $dbRes = $db->query($q);
        $overwrittenFiles = array();
        while($row = $db->fetchByAssoc($dbRes)) {
            $backup_path = clean_path( remove_file_extension($row['filename'])."-restore" );
            if(is_dir($backup_path)) {
                foreach(self::scandirRecursively($backup_path) as $f) {
                    $overwrittenFiles[$f][$row['id_name']] = $row['id_name'];
                }
            }
        }
        foreach($overwrittenFiles as $f => $idArr) {
            if(count($idArr) > 1) {
                echo "$f\n";
                foreach($idArr as $id => $id1) {
                    echo "    $id\n";
                }
                echo "\n";
            }
        }
    }

    public function listInstalled($keyword = null, $options = array())
    {
        global $db;
        $q = "SELECT id_name, version FROM upgrade_history WHERE status = 'installed'";
        if(!empty($keyword)) {
            $q .= " AND UPPER(id_name) LIKE '%".$db->quote(strtoupper($keyword))."%'";
        }
        $q .= " ORDER BY id_name ASC, date_entered DESC";
        $dbRes = $db->query($q);
        if(empty($options['each-version'])) {
            $packs = array();
            while($row = $db->fetchByAssoc($dbRes)) {
                $packs[$row['id_name']][] = $row['version'];
            }
            foreach($packs as $id_name => $versions) {
                echo "  ",$id_name,"-",implode(' -', $versions),"\n";
            }
        }
        else {
            foreach($stmt->fetchAll() as $row) {
                echo "  {$row['id_name']}-{$row['version']}\n";
            }
        }
    }

    public function listLoaded($keyword = null, $options = array())
    {
        global $db;
        $q = "SELECT id_name, version FROM stage WHERE 1";
        if(!empty($keyword)) {
            $q .= " AND id_name LIKE '%".trim($this->getDb()->quote($keyword), "'")."%'";
        }
        $q .= " ORDER BY id_name ASC, version COLLATE NATURAL_CMP DESC";
        $stmt = $this->getDb()->query($q);
        if(empty($options['each-version'])) {
            $packs = array();
            foreach($stmt->fetchAll() as $row) {
                $packs[$row['id_name']][] = $row['version'];
            }
            foreach($packs as $id_name => $versions) {
                echo "  ",$id_name,"-",implode(' -', $versions),"\n";
            }
        }
        else {
            foreach($stmt->fetchAll() as $row) {
                echo "  {$row['id_name']}-{$row['version']}\n";
            }
        }
    }

    public function listAvailable($keyword = null, $options = array())
    {
        $q = "SELECT id_name, version FROM available WHERE 1";
        if(!empty($keyword)) {
            $q .= " AND id_name LIKE '%".trim($this->getUserDb()->quote($keyword), "'")."%'";
        }
        $q .= " ORDER BY id_name ASC, version COLLATE NATURAL_CMP DESC";
        $stmt = $this->getUserDb()->query($q);
        if(empty($options['each-version'])) {
            $packs = array();
            foreach($stmt->fetchAll() as $row) {
                $packs[$row['id_name']][] = $row['version'];
            }
            foreach($packs as $id_name => $versions) {
                echo "  ",$id_name,"-",implode(' -', $versions),"\n";
            }
        }
        else {
            foreach($stmt->fetchAll() as $row) {
                echo "  {$row['id_name']}-{$row['version']}\n";
            }
        }
    }

    public function listFileInfo($fileInfo)
    {
        echo "{$fileInfo['file']}:\n";
        if(!empty($fileInfo['packages'])) {
            foreach($fileInfo['packages'] as $info) {
                echo "  {$info['type']} {$info['filename_from']} from {$info['package_id_name']}-{$info['package_version']}"
                    .($info['modified'] === null ? "" : " ".($info['modified'] ? "(modified)" : "(not modified)"))
                    .(!empty($info['overwrites']) ? ' - overwrites '.implode(' ', $info['overwrites']) : '')
                    ."\n";
            }
        }
        if(!empty($fileInfo['original'])) {
            echo "  SugarCRM ".($fileInfo['original']['modified'] ? "(modified)" : "(not modified)")."\n";
        }
        if(!empty($fileInfo['autogenerated'])) {
            echo "  autogenerated\n";
        }
    }

    public function getFileInfo($file)
    {
        $fileInfo = array(
            'file' => $file,
            'packages' => array(),
            'original' => null,
            'conflict' => false,
        );
        $stmt = $this->getDb()->prepare("SELECT package_id_name, package_version, crc, type, filename_from FROM files WHERE filename = :filename ORDER BY date_entered DESC");
        $stmt->execute(array(
            ':filename' => $file,
        ));
        $rows = $stmt->fetchAll();
        if(!empty($rows)) {
            $crc = hash_file('crc32b', $file);
            $firstRow = reset($rows);
            $overwrittenBy = $firstRow['package_id_name'];
            $overwrites = isset($this->packagesOverwrites[$firstRow['package_id_name']]) ? $this->packagesOverwrites[$firstRow['package_id_name']] : array();
        }
        $allNotModified = true;
        foreach($rows as $info) {
            $info['modified'] = $info['crc'] === null ? null : sprintf("%u",$info['crc']) != hexdec($crc);
            if($info['modified']) {
                $allNotModified = false;
            }
            $info['overwrites'] = isset($this->packagesOverwrites[$info['package_id_name']]) ? $this->packagesOverwrites[$info['package_id_name']] : array();
            $fileInfo['packages'][] = $info;
            if($info['package_id_name'] != $overwrittenBy && !in_array($info['package_id_name'], $overwrites)) {
                $fileInfo['conflict'] = true;
            }
        }
        if($allNotModified) {
            $fileInfo['conflict'] = false;
        }
        if($this->isFileAutogenerated($file)) {
            $fileInfo['autogenerated'] = true;
            $fileInfo['conflict'] = true;
        }

        static $md5 = array();
        if(empty($md5) && file_exists('files.md5'))
        {
            include('files.md5');
            $md5 = $md5_string;
        }
        if(isset($md5['./' . $file])) {
            $fileInfo['original'] = array(
                'modified' => md5_file($file) != $md5['./' . $file],
            );
        }
        return $fileInfo;
    }

    public function isFileAutogenerated($file)
    {
        $pathPatterns = array(
            '#^custom/modules/[^/]+/logic_hooks\.php$#',
            '#^custom/modules/logic_hooks\.php$#',
            '#^custom/modules/[^/]+/Ext/.+$#',
            '#^custom/application/Ext/.+$#',
            '#^custom/Extension/application/Ext/TableDictionary/.+$#',
            '#^custom/Extension/application/Ext/Include/.*\.php$#',
            //при добавлении шаблона добавить также в sql в функции check
        );
        foreach($pathPatterns as $pattern) {
            if(preg_match($pattern, $file)) {
                return true;
            }
        }
        return false;
    }

    public function check($showAll = false)
    {
        $stmt = $this->getDb()->prepare(
        "SELECT filename FROM (
            SELECT DISTINCT filename, package_id_name FROM files
        ) t
        GROUP BY filename
        HAVING count(*) > 1
        UNION
        SELECT DISTINCT filename FROM files
        WHERE filename LIKE 'custom/%/logic_hooks.php'
            OR filename LIKE 'custom/modules/%/Ext/%'
            OR filename LIKE 'custom/application/Ext/%'
            OR filename LIKE 'custom/Extension/application/Ext/TableDictionary/%'
            OR filename LIKE 'custom/Extension/application/Ext/Include/%.php'
        ORDER BY filename");
        if(!$stmt) {
            throw new Exception(implode(' ', $this->getDb()->errorInfo()));
        }
        $stmt->execute();
        $rows = $stmt->fetchAll();

        foreach($rows as $file) {
            $fileInfo = $this->getFileInfo($file['filename']);
            if($fileInfo['conflict'] || $showAll) {
                $this->listFileInfo($fileInfo);
            }
        }
    }

    public function checkModified()
    {
        echo "\nModified:\n";
        require_once 'include/utils/file_utils.php';
        $md5_string_calculated = $this->getMd5Array(); //TODO: unnecessary md5
        foreach($md5_string_calculated as $filename => $md5) {
            if(substr($filename, 0, 2) == './') {
                $filename = substr($filename, 2);
            }
            $fileInfo = $this->getFileInfo($filename);
            $newOrModified = empty($fileInfo['original']) || $fileInfo['original']['modified'];
            if($newOrModified && empty($fileInfo['autogenerated'])) {
                if(empty($fileInfo['packages'])) {
                    $this->listFileInfo($fileInfo);
                }
                else {
                    $lastPackage = reset($fileInfo['packages']);
                    if($lastPackage['modified']) {
                        $this->listFileInfo($fileInfo);
                    }
                }
            }
        }
    }

    public function install($id_name, $version = null, $options = array())
    {
        global $db;
        $stmt = $this->getDb()->prepare("SELECT id_name, version, filename, type FROM stage WHERE id_name = :id_name AND (version = :version OR :version IS NULL) ORDER BY version COLLATE NATURAL_CMP DESC");
        $stmt->execute(array(
            ':id_name' => $id_name,
            ':version' => $version,
        ));
        $packages = $stmt->fetchAll();
        if(empty($packages)) {
            throw new Exception("Package $id_name not found. It must be uploaded to SugarCRM.");
        }
        if(count($packages) > 1) {
            $msg = "There are some files with the same id:";
            foreach($packages as $pack) {
                $msg .= "\n  {$pack['version']} {$pack['filename']}";
            }
            throw new Exception($msg);
        }
        $pack = reset($packages);
        if($pack['type'] != 'module' && $pack['type'] != 'langpack') {
            throw new Exception("Installing package of type '{$pack['type']}' is not implemented.");
        }
        $version = $pack['version'];
        $file_to_install = $pack['filename'];
        if(!is_file($file_to_install)) {
            throw new Exception("File $file_to_install not found.");
        }

        $q = "SELECT version FROM upgrade_history WHERE UPPER(id_name) = '".$db->quote(strtoupper($id_name))
            ."' ORDER BY date_entered DESC";
        $dbRes = $db->query($q);
        while($row = $db->fetchByAssoc($dbRes)) {
            if(strnatcmp($row['version'], $version) != -1) {
                throw new Exception("You are trying to install older version. Version {$row['version']} already installed.");
            }
        }

        if(!empty($options['lock-file'])) {
            $this->lockFile = $options['lock-file'];
        }
        if(!empty($options['log-file'])) {
            $this->logFile = $options['log-file'];
        }

        self::createLock("install $id_name-$version");
        echo "Installing package {$pack['id_name']} {$pack['version']} file $file_to_install ...\n";
        $sugarcrmLogFile = $GLOBALS['sugar_config']['logger']['file']['name'].$GLOBALS['sugar_config']['logger']['file']['ext'];
        $md5 = file_exists($sugarcrmLogFile) ? md5_file($sugarcrmLogFile) : md5('');
        $pm = new SpmPackageManager();
        $file_to_install = UploadStream::path($file_to_install);
        $_REQUEST['install_file'] = $file_to_install;
        $pm->options = $options;
        $pm->performInstall($file_to_install);
        $this->log("install   {$pack['id_name']}-{$pack['version']} ".implode(',', array_keys($options)));
        if(md5_file($sugarcrmLogFile) != $md5) {
            echo "sugarcrm.log was modified; logger.level = {$GLOBALS['sugar_config']['logger']['level']}.\n";
        }
        self::releaseLock();
    }

    public function isUploaded($id_name, $version)
    {
        $stmt = $this->getDb()->prepare("SELECT 1 FROM stage WHERE id_name = :id_name AND version = :version LIMIT 1");
        $stmt->execute(array(
            ':id_name' => $id_name,
            ':version' => $version,
        ));
        $rows = $stmt->fetchAll();
        return !empty($rows);
    }

    public function isInstalled($id_name)
    {
        global $db;
        $q = "SELECT id_name FROM upgrade_history WHERE UPPER(id_name) = '".$db->quote(strtoupper($id_name))."'";
        $dbRes = $db->query($q);
        return (bool)$db->fetchByAssoc($dbRes);
    }

    public function uninstall($id_name, $version = null, $options = array())
    {
        global $db;
        $q = "SELECT id_name, version, type, filename FROM upgrade_history WHERE UPPER(id_name) = '".$db->quote(strtoupper($id_name))
            ."' ORDER BY date_entered DESC";
        $dbRes = $db->query($q);
        $packages = array();
        while($row = $db->fetchByAssoc($dbRes)) {
            $packages[] = $row;
        }
        if(empty($packages)) {
            throw new Exception("Package with id {$id_name} is not installed");
        }
        $package = reset($packages);
        if($package['type'] != 'module' && $package['type'] != 'langpack') {
            throw new Exception("Uninstalling package of type '{$package['type']}' is not implemented.");
        }
        $lastVersion = $package['version'];
        if(!$version) {
            $version = $lastVersion;
        }
        elseif($version != $lastVersion) {
            throw new Exception("You should uninstall last installed version (namely $lastVersion)");
        }
        $id_name = $package['id_name'];
        $version = $package['version'];

        $target_manifest = remove_file_extension($package['filename']) . "-manifest.php";
        if(file_exists($target_manifest)) {
            $manifest = null;
            include $target_manifest;
            if(isset($manifest['is_uninstallable']) && !$manifest['is_uninstallable'] && empty($options['not-uninstallable'])) {
                throw new Exception("Package is not uninstallable. But you can use option --not-uninstallable to uninstall it.");
            }
        }

        if(!empty($options['lock-file'])) {
            $this->lockFile = $options['lock-file'];
        }
        if(!empty($options['log-file'])) {
            $this->logFile = $options['log-file'];
        }

        //dependencies not checked here at all, Sugar checks straight dependencies, but it should checks reverse dependencies
        self::createLock("uninstall $id_name-$version");
        echo "Uninstalling package $id_name $version ...\n";
        $sugarcrmLogFile = $GLOBALS['sugar_config']['logger']['file']['name'].$GLOBALS['sugar_config']['logger']['file']['ext'];
        $md5 = file_exists($sugarcrmLogFile) ? md5_file($sugarcrmLogFile) : md5('');
        $pm = new SpmPackageManager();
        $GLOBALS['mi_remove_tables'] = !empty($options['remove-tables']);
        $pm->options = $options;
        $pm->performUninstall($id_name, $version);
        echo "\n";
        $this->log("uninstall {$id_name}-{$version} ".implode(',', array_keys($options)));
        if(md5_file($sugarcrmLogFile) != $md5) {
            echo "sugarcrm.log was modified; logger.level = {$GLOBALS['sugar_config']['logger']['level']}.\n";
        }
        self::releaseLock();
    }

    public function remove($id_name, $version = null)
    {
        $stmt = $this->getDb()->prepare("SELECT version, filename FROM stage WHERE id_name = :id_name AND (version = :version OR :version IS NULL) ORDER BY version COLLATE NATURAL_CMP DESC");
        $stmt->execute(array(':id_name' => $id_name, ':version' => $version));
        $packages = $stmt->fetchAll();
        if(empty($packages)) {
            throw new Exception("Package $id_name $version not found.");
        }
        require_once('ModuleInstall/PackageManager/PackageController.php');
        $pmc = new PackageController();
        foreach($packages as $pack) {
            echo "Removing {$pack['filename']} ...\n";
            $hash = md5($pack['filename']);
            $_SESSION['file2Hash'][$hash] = $pack['filename'];
            $_REQUEST['file'] = $hash;
            ob_start();
            $pmc->remove();
            ob_clean();
            unset($_SESSION['file2Hash'][$hash]);
        }
    }

    public function upload($id_name, $version = null, $options = array())
    {
        $stmt = $this->getUserDb()->prepare("SELECT version, filename FROM available WHERE id_name = :id_name AND (version = :version OR :version IS NULL) ORDER BY version COLLATE NATURAL_CMP DESC LIMIT 1");
        if(!$stmt) {
            throw new Exception(implode(' ', $this->getUserDb()->errorInfo()));
        }
        $stmt->execute(array(':id_name' => $id_name, ':version' => $version));
        $row = $stmt->fetch();
        if(empty($row)) {
            throw new Exception("Package $id_name $version not found (spm_path = {$this->spmPath}).");
        }
        $manifest_file = $row['filename'].'/manifest.php';
        if(!is_file($manifest_file)) {
            throw new Exception("File {$manifest_file} not found.");
        }
        $manifest = $installdefs = null;
        include $manifest_file;
        $id_name1 = !empty($installdefs['id']) ? $installdefs['id'] : $manifest['name'];
        $version1 = $manifest['version'];
        if(strcasecmp($id_name1, $id_name) != 0 || ($version && strcasecmp($version1, $version) != 0)) {
            throw new Exception("Id/version mismatch.");
        }
        require_once 'modules/UpgradeWizard/uw_utils.php';
        $err = validate_manifest($manifest);
        if($err) {
            throw new Exception($err);
        }
        /* Проверка синтаксиса */
        if(empty($options['no-php-check'])) {
            $command = "cd {$row['filename']}; pwd; find . -name \"*.php\" -exec php -l {} \; ";
            $out = `$command`;
            if(strpos($out, 'Errors parsing')) {
                throw new Exception($out);
            }
        }

        $upgrade_zip_type = $manifest['type'];
        // exclude the bad permutations
        if ($upgrade_zip_type != "module" && $upgrade_zip_type != "theme" && $upgrade_zip_type != "langpack") {
            throw new Exception("'$upgrade_zip_type' is not acceptable type.");
        }

        $base_filename = "{$id_name1}-{$version1}.zip";
        $base_upgrade_dir = "upload://upgrades";
        $target_path = "$base_upgrade_dir/$upgrade_zip_type/$base_filename";
        if(file_exists($target_path)) {
            throw new FileAlreadyExistsException("File $target_path already exists.");
        }

        echo "Uploading package $id_name1 {$row['version']} from {$row['filename']} ...\n";
        if(!is_dir("$base_upgrade_dir/$upgrade_zip_type") && !UploadStream::mkdir("$base_upgrade_dir/$upgrade_zip_type", 0770, STREAM_MKDIR_RECURSIVE)) {
            throw new Exception("Cannot create directory $base_upgrade_dir/$upgrade_zip_type.");
        };
        /* Создание zip-пакета */
        $command = "cd {$row['filename']}; pwd; zip -r '".getcwd()."/".UploadStream::path($target_path)."' ./* -x \"*.git*\"";
        $out = `$command`;
        $hasErrors = strpos($out, 'warning: ');
        if(!is_file($target_path)) {
            throw new Exception("Cannot create file $target_path.\n".$out);
        }

        $target_manifest = remove_file_extension( $target_path ) . "-manifest.php";
        copy( $manifest_file, $target_manifest );

        if( isset($manifest['icon']) && $manifest['icon'] != "" ){
             $icon_location = $row['filename'].'/'.$manifest['icon'];
             copy($icon_location, remove_file_extension( $target_path )."-icon.".pathinfo($icon_location, PATHINFO_EXTENSION));
        }

        if($hasErrors) {
            echo "File uploaded, but there was warnings: ",$out;
        }
    }

    public function zip($id_name, $version = null, $options = array())
    {
        $stmt = $this->getUserDb()->prepare("SELECT version, filename FROM available WHERE id_name = :id_name AND (version = :version OR :version IS NULL) ORDER BY version COLLATE NATURAL_CMP DESC LIMIT 1");
        if(!$stmt) {
            throw new Exception("Error on getting available packages");
        }
        $stmt->execute(array(':id_name' => $id_name, ':version' => $version));
        $row = $stmt->fetch();
        if(empty($row)) {
            throw new Exception("Package $id_name $version not found (spm_path = {$this->spmPath}).");
        }
        $manifest_file = $row['filename'].'/manifest.php';
        if(!is_file($manifest_file)) {
            throw new Exception("File {$manifest_file} not found.");
        }
        $manifest = $installdefs = null;
        include $manifest_file;
        $id_name1 = !empty($installdefs['id']) ? $installdefs['id'] : $manifest['name'];
        $version1 = $manifest['version'];
        if(strcasecmp($id_name1, $id_name) != 0 || ($version && strcasecmp($version1, $version) != 0)) {
            throw new Exception("Id/version mismatch.");
        }
        /* Проверка синтаксиса */
        if(empty($options['no-php-check'])) {
            $command = "cd {$row['filename']}; pwd; find . -name \"*.php\" -exec php -l {} \; ";
            $out = `$command`;
            if(strpos($out, 'Errors parsing')) {
                throw new Exception($out);
            }
        }

        $i = 0;
        do {
            $target_path = $this->cwd."/{$id_name1}-{$version1}".($i ? "($i)" : "").".zip";
            $i++;
        }
        while(file_exists($target_path));

        echo "Creating file {$target_path} ...\n";
        /* Создание zip-пакета */
        $command = "cd {$row['filename']}; pwd; zip -r '".$target_path."' ./* -x \"*.git*\"";
        $out = `$command`;
        $hasErrors = strpos($out, 'warning: ');
        if(!is_file($target_path)) {
            throw new Exception("Cannot create file $target_path.\n".$out);
        }

        if($hasErrors) {
            echo "File created, but there was warnings: ",$out;
        }
    }

    public function updateStage()
    {
        $this->repairManifests();
        $pm = new PackageManager();
        $packs = $pm->getPackagesInStaging();
        $this->packagesInStaging = array();
        $this->getDb()->exec("DROP TABLE IF EXISTS stage");
        $this->getDb()->exec("CREATE TABLE stage (id_name TEXT COLLATE NOCASE, version TEXT, filename TEXT, type TEXT)");
        $stmt = $this->getDb()->prepare("INSERT INTO stage (id_name, version, filename, type) VALUES (:id_name, :version, :filename, :type)");
        $stmt->bindParam(':id_name', $id_name);
        $stmt->bindParam(':version', $version);
        $stmt->bindParam(':filename', $filename);
        $stmt->bindParam(':type', $type);
        foreach($packs as $key => $pack) {
            if(!empty($pack['name'])) {
                $upgrade_content = hashToFile($pack['file']);
                $target_manifest = remove_file_extension( $upgrade_content ) . '-manifest.php';
                if(file_exists($target_manifest)) {
                    $manifest = $installdefs = null;
                    require($target_manifest);
                    $id_name = !empty($installdefs['id']) ? $installdefs['id'] : null;
                    $version = $manifest['version'];
                    $filename = hashToFile($pack['file']);
                    $type = $manifest['type'];
                    $stmt->execute();
                    $this->packagesInStaging["$id_name-$version"] = array(
                        'id_name' => $id_name,
                        'version' => $version,
                        'filename' => $filename,
                        'type' => $type,
                    );
                }
                else {
                    echo "Warning: $target_manifest not exists while update stage\n";
                }
            }
        }
    }

    public function repairManifests()
    {
        $zips = glob(UploadStream::path("upload://upgrades").'/{module,langpack}/*.zip', GLOB_BRACE);
        foreach($zips as $zip) {
            $target_manifest = remove_file_extension($zip) . '-manifest.php';
            if(!file_exists($target_manifest)) {
                copy("zip://$zip#manifest.php", $target_manifest);
            }
        }
    }

    public function updateAvailable($options = array())
    {
        $this->getUserDb()->exec("DROP TABLE IF EXISTS available");
        $this->getUserDb()->exec("CREATE TABLE available (id_name TEXT COLLATE NOCASE, version TEXT, filename TEXT)");
        $stmt = $this->getUserDb()->prepare("INSERT INTO available (id_name, version, filename) VALUES (:id_name, :version, :filename)");
        $stmt->bindParam(':id_name', $id_name);
        $stmt->bindParam(':version', $version);
        $stmt->bindParam(':filename', $filename);
        if(!empty($options['spm-path'])) {
            $this->spmPath = $options['spm-path'];
        }
        if(empty($this->spmPath)) {
            $this->spmPath = getenv('SPM_PATH');
        }
        if(empty($this->spmPath)) {
            echo "No SPM_PATH defined. You may define environment variable SPM_PATH or option --spm-path=<path>.\n";
        }
        $paths = explode(':', $this->spmPath);
        foreach($paths as $path) {
            if($path) {
                if(is_dir($path)) {
                    $packs = self::searchPackages(rtrim($path, '/'));
                    foreach($packs as $key => $pack) {
                        extract($pack);
                        $stmt->execute();
                        $this->packagesAvailable[] = $pack;
                    }
                }
                else {
                    echo "Warning: directory $path not exists.\n";
                }
            }
        }
    }

    public function searchFileInAvailable($file)
    {
        $stmt = $this->getUserDb()->prepare("SELECT filename FROM available WHERE id_name = :id_name ORDER BY version COLLATE NATURAL_CMP DESC");
        if(!$stmt) {
            throw new Exception(implode(' ', $this->getUserDb()->errorInfo()));
        }
        $files = array();
        $fileInfo = $this->getFileInfo($file);
        if(!empty($fileInfo['packages'])) {
            foreach($fileInfo['packages'] as $info) {
                $stmt->execute(array(':id_name' => $info['package_id_name']));
                foreach($stmt->fetchAll() as $packRow) {
                    $f = realpath($packRow['filename'].'/'.$info['filename_from']);
                    if(file_exists($f)) {
                        $files[$f] = array(
                            'path' => $f,
                            'info' => $info,
                        );
                    }
                }
            }
        }
        return $files;
    }

    protected static function searchPackages($path, $prefix = '')
    {
        $packages = array();
        if(is_file($path.'/manifest.php')) {
            $manifest = $installdefs = null;
            include $path.'/manifest.php'; //user must add only trusted sources
            if((!empty($manifest['name']) || !empty($installdefs['id'])) && !empty($manifest['version'])) {
                $packages[] = array(
                    'filename' => $path,
                    'id_name' => !empty($installdefs['id']) ? $installdefs['id'] : $manifest['name'],
                    'version' => $manifest['version'],
                );
                return $packages;
            }
        }
        foreach(scandir($path) as $f) {
            if($f != '.' && $f != '..') {
                if(is_dir($path.'/'.$f)) {
                    $packages = array_merge($packages, self::searchPackages($path.'/'.$f, $prefix.$f.'/'));
                }
            }
        }
        return $packages;
    }

    public function updateCopiedFiles()
    {
        global $db;
        if(!class_exists('ZipArchive')) {
            throw new Exception("ZipArchive class required but not exists.");
        }
        $this->getDb()->exec("DROP TABLE IF EXISTS files");
        $this->getDb()->exec("CREATE TABLE files (filename TEXT, filename_from TEXT, package_id_name TEXT COLLATE NOCASE, package_version TEXT, crc INT, type TEXT, date_entered TEXT)");
        $stmt = $this->getDb()->prepare("INSERT INTO files (filename, filename_from, package_id_name, package_version, crc, type, date_entered)
            VALUES (:filename, :filename_from, :id_name, :version, :crc, :type, :date_entered)");
        $stmt->bindParam(':filename', $filename);
        $stmt->bindParam(':filename_from', $filename_from);
        $stmt->bindParam(':id_name', $id_name);
        $stmt->bindParam(':version', $version);
        $stmt->bindParam(':crc', $crc);
        $stmt->bindParam(':type', $type);
        $stmt->bindParam(':date_entered', $date_entered);

        $sql = "SELECT id_name, version, filename, date_entered FROM upgrade_history ORDER BY id_name ASC, date_entered DESC";
        $dbRes = $db->query($sql);
        $sugarPath = getcwd();
        $mi = new ModuleInstaller();
        while($row = $db->fetchByAssoc($dbRes)) {
            $manifestFile = remove_file_extension($row['filename']).'-manifest.php';
            if(file_exists($manifestFile) && file_exists($row['filename'])) {
                $id_name = $row['id_name'];
                $version = $row['version'];
                $package_filename = $row['filename'];
                $date_entered = $row['date_entered'];
                $manifest = $installdefs = null;
                require $manifestFile;
                if(empty($installdefs)) {
                    continue;
                }
                $copyDefs = array();

                if(!empty($installdefs['copy'])) {
                    foreach($installdefs['copy'] as $cp) {
                        $from = clean_path(ltrim(str_replace('<basepath>', '', $cp['from']), '/'));
                        $to = ltrim(substr(realpath($sugarPath.'/'.str_replace('<basepath>', '.', $cp['to'])), strlen($sugarPath)), '/');
                        $copyDefs[] = array(
                            'from' => $from,
                            'to' => $to,
                            'type' => 'copy',
                        );
                    }
                }

                if(!empty($installdefs['image_dir'])) {
                    $from = clean_path(ltrim(str_replace('<basepath>', '', $installdefs['image_dir']), '/'));
                    $to = ltrim(substr(realpath($sugarPath.'/custom/themes'), strlen($sugarPath)), '/');
                    $copyDefs[] = array(
                        'from' => $from,
                        'to' => $to,
                        'type' => 'image_dir',
                    );
                }

                foreach($mi->extensions as $extname => $ext) {
                    $section = $ext["section"];
                    if(!method_exists($mi, "install_$extname") && !empty($ext["section"])) {
                        $extname = $ext["extdir"];
                        $module = isset($ext['module']) ? $ext['module'] : '';
                        if(isset($installdefs[$section])) {
                            foreach($installdefs[$section] as $item) {
                                if(!empty($module)) {
                                    $item['to_module'] = $module;
                                }
                                if(empty($item['to_module'])) {
                                    continue;
                                }
                                if(isset($item['from'])) {
                                    $from = ltrim(str_replace('<basepath>', '', $item['from']), '/');
                                } else {
                                    $from = '';
                                }
                                if($item['to_module'] == 'application') {
                                    $path = "custom/Extension/application/Ext/$extname";
                                } else {
                                    $path = "custom/Extension/modules/{$item['to_module']}/Ext/$extname";
                                }
                                if(isset($item["name"])) {
                                    $target = $item["name"];
                                } else if (!empty($from)){
                                    $target = basename($from, ".php");
                                } else {
                                    $target = $id_name;
                                }
                                $copyDefs[] = array(
                                    'from' => $from ? $from : 'manifest.php',
                                    'to' => "$path/$target.php",
                                    'type' => $section,
                                );
                            }
                        }
                    }
                }

                if(!empty($installdefs['language'])) {
                    foreach($installdefs['language'] as $packs) {
                        if(empty($packs['from']) || empty($packs['to_module'])) {
                            continue;
                        }
                        $from = ltrim(str_replace('<basepath>', '', $packs['from']), '/');

                        $path = 'custom/Extension/modules/' . $packs['to_module']. '/Ext/Language';
                        if($packs['to_module'] == 'application'){
                            $path ='custom/Extension/' . $packs['to_module']. '/Ext/Language';
                        }
                        $path .= '/'.$packs['language'].'.'. $id_name . '.php';

                        $copyDefs[] = array(
                            'from' => $from,
                            'to' => $path,
                            'type' => 'language',
                        );
                    }
                }

                if(!empty($installdefs['relationships'])) {
                    foreach($installdefs['relationships'] as $relationship) {
                        if(empty($relationship['meta_data'])) {
                            continue;
                        }
                        $from = ltrim(str_replace('<basepath>', '', $relationship['meta_data']), '/');
                        $filename = basename ( $relationship [ 'meta_data' ] ) ;
                        $path = 'custom/metadata/' . $filename;
                        $copyDefs[] = array(
                            'from' => $from,
                            'to' => $path,
                            'type' => 'relationships',
                        );
                        //TODO: module_vardefs, module_layoutdefs
                    }
                }

                //TODO: custom_fields, dashlets, dcaction, connectors
                if(empty($copyDefs)) {
                    continue;
                }

                $zip = new ZipArchive;
                $res = $zip->open($package_filename);
                if ($res === TRUE) {
                    for($i = 0; $i < $zip->numFiles; $i++) {
                        $stat = $zip->statIndex($i);
                        if(!empty($stat['crc'])) {
                            $filename = false;
                            $filename_from = false;
                            $cp1 = false;
                            foreach($copyDefs as $cp) {
                                if(strpos($stat['name'], $cp['from']) === 0) {
                                    $filename = rtrim(($cp['to'] ? $cp['to'].'/' : '').ltrim(substr($stat['name'], strlen($cp['from'])), '/'), '/');
                                    $filename_from = $stat['name'];
                                    $cp1 = $cp;
                                    break;
                                }
                            }
                            if($filename) {
                                $crc = $cp1['from'] == 'manifest.php' ? null : $stat['crc'];
                                $type = $cp1['type'];
                                $stmt->execute();
                            }
                        }
                    }
                    $zip->close();
                } else {
                    echo "Error: zip {$row['filename']} not opened, code: ", $res, "\n";
                }
            }
        }
    }

    public function repair($options = array())
    {
        $randc = new SpmRepairAndClear();
        $show_output = !empty($options['v']);
        if($show_output) {
            ob_start();
            $randc->oneLine = false;
        }
        $randc->repairAndClearAll(array('clearAll'),array(translate('LBL_ALL_MODULES')), false, $show_output);
        if($show_output) {
            echo "\n";
            ob_flush();
        }
        if($randc->sql) {
            echo "/* Differences found between database and vardefs. */
/* You may run `spm dbquery \"<sql>\"`. */\n\n";
            echo $randc->sql,"\n\n";
        }

        require_once 'modules/Configurator/Configurator.php';
        $configuratorObj = new Configurator();
        $configuratorObj->loadConfig();
        $js_custom_version = empty($configuratorObj->config['js_custom_version']) || !is_numeric($configuratorObj->config['js_custom_version'])
            ? 100 : $configuratorObj->config['js_custom_version'];
        $configuratorObj->config['js_custom_version'] = $js_custom_version + 1;
        $js_lang_version = empty($configuratorObj->config['js_lang_version']) || !is_numeric($configuratorObj->config['js_lang_version'])
            ? 100 : $configuratorObj->config['js_lang_version'];
        $configuratorObj->config['js_lang_version'] = $js_lang_version + 1;
        $configuratorObj->saveConfig();
    }

    public function dbquery($sql, $allowedQueries = null, $options = array())
    {
        global $db;
        $sql = str_replace(
            array(
                "\n",
                '&#039;',
            ),
            array(
                '',
                "'",
            ),
            preg_replace('#(/\*.+?\*/\n*)#', '', $sql)
        );
        foreach (explode(";", $sql) as $stmt) {
            $stmt = trim($stmt);

            if (!empty ($stmt)) {
                if($allowedQueries !== null && empty($options['f'])) {
                    if(!in_array($stmt, $allowedQueries)) {
                        if(!empty($options['s'])) {
                            continue;
                        }
                        throw new Exception("Statement is not allowed. Write it into .spmqueries.php file or use command options to force query: {$stmt}");
                    }
                }
                echo "Query: $stmt\n";
                $res = $db->query($stmt,true,'Executing repair query from spm: ');
                $head = $db->getFieldsArray($res);
                if(!empty($head)) {
                    while($row = $db->fetchByAssoc($res, false)) {
                        print_r($row);
                    }
                }
                echo ($res ? "Done" : "Fail"),"\n";
            }
        }
    }

    protected function getDb()
    {
        if(!$this->db) {
            try {
                $this->db = new PDO('sqlite::memory:');
                $this->db->sqliteCreateCollation('NATURAL_CMP', 'strnatcmp');
            }
            catch(PDOException $e) {
                echo "Connection to sqlite failed\n";
                $this->db = new SpmPDO();
                $this->db->spm = $this;
                $this->db->lastException = $e;
            }
        }
        return $this->db;
    }

    protected function getUserDb()
    {
        if(!$this->userDb) {
            try {
                $this->userDb = new PDO('sqlite::memory:');
                $this->userDb->sqliteCreateCollation('NATURAL_CMP', 'strnatcmp');
            }
            catch(PDOException $e) {
                echo "Connection to sqlite failed\n";
                $this->userDb = new SpmPDO();
                $this->userDb->spm = $this;
                $this->userDb->lastException = $e;
            }
        }
        return $this->userDb;
    }

    protected function log($msg)
    {
        file_put_contents($this->logFile, date('Y-m-d H:i:s')." [".get_current_user()."]: ".$msg."\n", FILE_APPEND);
    }

    protected function hasLock() {
        return file_exists($this->lockFile);
    }

    protected function createLock($action = '')
    {
        if(file_exists($this->lockFile)) {
            throw new Exception("Probably other installation in progress or exited with error. See {$this->lockFile} file.");
        }
        $r = file_put_contents($this->lockFile,
"Lock file generated by spm utility before installing/uninstalling package and removed after success.

action: {$action}
user: ".get_current_user()."
timestamp: ".date("Y-m-d H:i:s")."
"
);
        if($r === false) {
            throw new Exception("Fail to write {$this->lockFile} file");
        }
    }

    protected function releaseLock()
    {
        if(file_exists($this->lockFile)) {
            unlink($this->lockFile);
        }
    }

    /**
     * https://github.com/fayebsg/sugarcrm-cli.git
     *  + pea
     */
    public static function enterSugar()
    {
        global $sugar_config;
        if(!self::chdirToSugarRoot()) {
            return false;
        }

        if (!defined('sugarEntry')) {
            define('sugarEntry', true);
        }

        require('config.php');
        $GLOBALS['sugar_config'] = $sugar_config;
        require_once('include/entryPoint.php');

        // Scope is messed up due to requiring files within a function
        // We need to explicitly assign these variables to $GLOBALS
        foreach (get_defined_vars() as $key => $val) {
            $GLOBALS[$key] = $val;
        }

        if (empty($current_language)) {
            $current_language = $sugar_config['default_language'];
        }

        $GLOBALS['app_list_strings'] = return_app_list_strings_language($current_language);
        $GLOBALS['app_strings'] = return_application_language($current_language);
        $GLOBALS['mod_strings'] = array_merge(
            return_module_language($current_language, "Administration"),
            return_module_language($current_language, "UpgradeWizard")
        );

        global $current_user;
        $current_user = new User();
        $current_user->getSystemUser();

        if (UploadStream::getSuhosinStatus() == false) {
            echo "Warning: ",htmlspecialchars_decode($GLOBALS['app_strings']['ERR_SUHOSIN']),"\n";
        }
        return true;
    }

    protected static function chdirToSugarRoot($path = null)
    {
        if($path === null) {
            $path = getcwd();
        }
        if(self::isSugarDir($path)) {
            if(getcwd() != $path) {
                chdir($path);
            }
            return true;
        }
        $parentPath = dirname($path);
        if($parentPath == $path) {
            return false;
        }
        return self::chdirToSugarRoot($parentPath);
    }

    public static function isSugarDir($path = null)
    {
        if($path === null) {
            $path = getcwd();
        }
        return file_exists($path.'/sugar_version.php') && file_exists($path.'/include/entryPoint.php');
    }

    public static function cleanupSugar()
    {
        sugar_cleanup();
    }

    public static function scandirRecursively($path, $prefix = '')
    {
        $files = array();
        foreach(scandir($path) as $f) {
            if($f != '.' && $f != '..') {
                if(is_dir($path.'/'.$f)) {
                    $files = array_merge($files, self::scandirRecursively($path.'/'.$f, $prefix.$f.'/'));
                }
                else {
                    $files[] = $prefix.$f;
                }
            }
        }
        return $files;
    }

    public function sandboxInit($options = array())
    {
        global $db;
        if($this->hasSandbox()) {
            throw new Exception("Sandbox file {$this->sandboxFile} already exists");
        }
        echo "Creating file {$this->sandboxFile}\n";
        file_put_contents($this->sandboxFile,
"; For each package use section with unique name.
; `path` defines relative path to folder with package sources.
; `id` defines package id_name.
; `version` must be specified.
; `environment` (optional) means that this package must be installed in some custom
;     environment other than production. Multiple environments separated by spaces.
; `overwrite` (optional) means that this package overwrites some packages and
;     must be reinstalled after them. Their id_names separated by spaces should be
;     defined here.
;
; Example:
; [example]
;     path = packages/example_dir
;     id = example_id
;     version = 1.0.0


");

        $packagesInDb = array();
        $q = "SELECT id_name, version FROM upgrade_history WHERE status = 'installed' ORDER BY date_entered";
        $dbRes = $db->query($q);
        while($row = $db->fetchByAssoc($dbRes)) {
            $key = $row['id_name'].(empty($options['no-merge']) ? '' : '-'.$row['version']);
            $packagesInDb[$key] = $row;
        }
        foreach($packagesInDb as $key => $row) {
            file_put_contents($this->sandboxFile, "
; [$key]
;     path =
;     id = {$row['id_name']}
;     version = {$row['version']}
", FILE_APPEND);
        }
    }

    public function hasSandbox()
    {
        return file_exists($this->sandboxFile);
    }

    public function sandboxStatus($environments = array(), $options = array())
    {
        $statusData = $this->getSandboxStatusData($options, $environments);
        $incorrectEnvironments = array_diff($environments, $statusData['environments']);
        if(!empty($incorrectEnvironments)) {
            echo "Warning: unknown environments - ".implode(' ', $incorrectEnvironments)."\n";
        }
        if(!empty($statusData['environments']) || !empty($environments)) {
            echo "Current environments: ".(empty($environments) ? "<default>" : implode(' ', $environments))
                .". Available environments: ".implode(' ', $statusData['environments']).".\n";
        }
        if(!empty($statusData['sandboxUnknown'])) {
            echo "New installed packages found (write to {$this->sandboxFile}):\n";
            foreach($statusData['sandboxUnknown'] as $row) {
                echo "  {$row['id_name']}-{$row['version']}\n";
            }
        }
        if(!empty($statusData['unknownReinstall'])) {
            echo "Packages to reinstall after installing these packages:\n";
            foreach($statusData['unknownReinstall'] as $pack) {
                echo "  {$pack['id']}-{$pack['version']}".(!empty($pack['environment']) ? " ({$pack['environment']})" : "")."\n";
            }
        }
        echo "\n";
        if(!empty($statusData['sandboxNotInstalled'])) {
            echo "Packages not yet installed (run `spm sandbox-install`):\n";
            foreach($statusData['sandboxNotInstalled'] as $pack) {
                echo "  {$pack['id']}-{$pack['version']}".(!empty($pack['environment']) ? " ({$pack['environment']})" : "")."\n";
            }
        }
        if(!empty($statusData['needReinstall'])) {
            echo "Packages to reinstall after installing new packages:\n";
            foreach($statusData['needReinstall'] as $pack) {
                echo "  {$pack['id']}-{$pack['version']}".(!empty($pack['environment']) ? " ({$pack['environment']})" : "")."\n";
            }
        }
    }

    public function getSandboxStatusData($options = array(), $environments = array())
    {
        global $db;
        if(!empty($options['input'])) {
            $ini_string = '';
            while($line = fgets(STDIN)) {
                $ini_string .= $line."\n";
            }
        }
        else {
            $file = !empty($options['file']) ? $options['file'] : $this->sandboxFile;
            if(!is_file($file)) {
                throw new Exception("Sandbox file $file not found. You should run `spm sandbox-init` or use --file=<path> option with correct path.");
            }
            $ini_string = file_get_contents($file);
        }
        $statusData = array(
            'sandboxUnknown' => array(),
            'sandboxNotInstalled' => array(),
            'environments' => array(),
            'needReinstall' => array(),
            'overwrites' => array(),
            'unknownReinstall' => array(),
        );
        $packagesInFile = parse_ini_string($ini_string, true);
        if($packagesInFile === false) {
            throw new Exception("Cannot parse sandbox file $file.");
        }

        $packagesInDb = array();
        $q = "SELECT id_name, version FROM upgrade_history WHERE status = 'installed' ORDER BY date_entered";
        $dbRes = $db->query($q);
        while($row = $db->fetchByAssoc($dbRes)) {
            $packagesInDb[] = $row;
        }

        foreach($packagesInDb as $row) {
            $inFile = false;
            foreach($packagesInFile as $pack) {
                if($pack['id'] == $row['id_name'] && strnatcmp($pack['version'], $row['version']) >= 0) {
                    $inFile = true;
                    break;
                }
            }
            if(!$inFile) {
                $row['id'] = $row['id_name'];
                $statusData['sandboxUnknown'][$row['id_name']] = $row;
            }
        }

        foreach($packagesInFile as $section => $pack) {
            foreach($pack as $key => $v) {
                if(!in_array($key, array('path','id','version','environment','overwrite'))) {
                    echo "Warning: unknown key $key in $section section\n";
                }
            }
            if(!empty($pack['environment'])) {
                $inCurrentEnvironments = false;
                foreach(explode(' ', $pack['environment']) as $env) {
                    $statusData['environments'][$env] = $env;
                    if(in_array($env, $environments)) {
                        $inCurrentEnvironments = true;
                    }
                }
            }
            else {
                $inCurrentEnvironments = true;
            }
            $packagesInFile[$section]['inCurrentEnvironments'] = $inCurrentEnvironments;
            if(!$inCurrentEnvironments) {
                continue;
            }
            $inDb = false;
            foreach($packagesInDb as $row) {
                if($pack['id'] == $row['id_name'] && strnatcmp($row['version'], $pack['version']) >= 0) {
                    $inDb = true;
                    break;
                }
            }
            if(!$inDb) {
                $statusData['sandboxNotInstalled'][] = $pack;
            }
        }

        foreach($packagesInFile as $section => $pack) {
            if(empty($pack['overwrite']) || !$pack['inCurrentEnvironments']) {
                continue;
            }
            $overwrites = array_filter(explode(' ', $pack['overwrite']));
            foreach($overwrites as $o) {
                $isKnown = false;
                foreach($packagesInFile as $pack2) {
                    if($pack2['id'] == $o) {
                        $isKnown = true;
                        break;
                    }
                }
                if(!$isKnown) {
                    throw new Exception("Error: Unknown package $o in $section section");
                }
            }
            $statusData['overwrites'][$pack['id']] = $overwrites;
        }

        $statusData['needReinstall'] = $this->getReinstalls($statusData['sandboxNotInstalled'], $packagesInFile);
        $statusData['unknownReinstall'] = $this->getReinstalls($statusData['sandboxUnknown'], $packagesInFile);
        return $statusData;
    }

    protected function getReinstalls($newPackages, $packagesInFile, $depth = 0)
    {
        if($depth >= 10) {
            throw new Exception("Max recursion level reached on reinstalls search");
        }
        foreach($newPackages as $id => $newPack) { //переустанавливать уже новую версию
            if(isset($packagesInFile[$id])) {
                $packagesInFile[$id]['version'] = $newPack['version'];
            }
        }
        $reinstallPackages = array();
        foreach($packagesInFile as $pack) {
            if(empty($pack['overwrite']) || !$pack['inCurrentEnvironments']) {
                continue;
            }
            $overwrites = array_filter(explode(' ', $pack['overwrite']));
            $needReinstall = false;
            foreach($newPackages as $pack2) {
                if($pack2['id'] == $pack['id']) {
                    $needReinstall = false;
                }
                elseif(in_array($pack2['id'], $overwrites)) {
                    $needReinstall = true;
                }
            }
            if($needReinstall) {
                $reinstallPackages[$pack['id']] = $pack;
            }
        }
        if(!empty($reinstallPackages)) {
            $reinstallPackages2 = $this->getReinstalls($reinstallPackages, $packagesInFile, $depth + 1);
            $reinstallPackages = array_merge(array_diff_key($reinstallPackages, $reinstallPackages2), $reinstallPackages2);
        }
        return $reinstallPackages;
    }

    public function updatePackagesOverwrites()
    {
        if($this->hasSandbox()) {
            $statusData = $this->getSandboxStatusData(); //TODO: environments
            $this->packagesOverwrites = $statusData['overwrites'];
        }
    }

    public function sandboxInstall($environments = array(), $options = array())
    {
        $statusData = $this->getSandboxStatusData($options, $environments);
        if(empty($statusData['sandboxNotInstalled'])) {
            return;
        }

        $this->updateStage();
        foreach($statusData['sandboxNotInstalled'] as $pack) {
            if(empty($pack['id'])) {
                throw new Exception('id must be specified in '.print_r($pack, true));
            }
            if(empty($pack['version'])) {
                throw new Exception('version must be specified in '.print_r($pack, true));
            }
            if(empty($pack['path'])) {
                throw new Exception('path must be specified in '.print_r($pack, true));
            }
            if($this->isUploaded($pack['id'], $pack['version'])) {
                continue;
            }
            $this->updateAvailable(array('spm-path' => $pack['path']));
            try {
                $this->upload($pack['id'], $pack['version']);
            }
            catch(FileAlreadyExistsException $ex) {
                echo $ex->getMessage()."\n";
            }
        }

        $installOptionsString = SpmCmd::optionsToString(SpmCmdInstall::$ALLOWED_OPTIONS, $options);
        $uninstallOptionsString = SpmCmd::optionsToString(SpmCmdUninstall::$ALLOWED_OPTIONS, $options);
        foreach($statusData['sandboxNotInstalled'] as $pack) {
            if($this->hasLock()) {
                throw new Exception("Probably other installation in progress or exited with error. See {$this->lockFile} file.");
            }
            if(empty($options['no-uninstall'])) {
                while($this->isInstalled($pack['id'])) {
                    echo shell_exec('/usr/bin/env php '.__FILE__.' uninstall '.$pack['id'].' '.$uninstallOptionsString);
                }
            }
            echo shell_exec('/usr/bin/env php '.__FILE__.' install '.$pack['id'].'-'.$pack['version'].' '.$installOptionsString); //exec new process to avoid redeclare errors (post_install, etc.)
        }

        foreach($statusData['needReinstall'] as $pack) {
            if($this->hasLock()) {
                throw new Exception("Probably other installation in progress or exited with error. See {$this->lockFile} file.");
            }
            echo shell_exec('/usr/bin/env php '.__FILE__.' uninstall '.$pack['id'].'-'.$pack['version'].' '.$uninstallOptionsString);
            echo shell_exec('/usr/bin/env php '.__FILE__.' install '.$pack['id'].'-'.$pack['version'].' '.$installOptionsString);
        }
    }

    public function md5Generate($file)
    {
        require_once 'include/utils/file_utils.php';
        if(file_exists($file)) {
            throw new Exception("File $file already exists.");
        }
        $md5_string_calculated = $this->getMd5Array();
        echo "Creating file $file\n";
        $res = write_array_to_file('md5_string_calculated', $md5_string_calculated, $file);
        if(!$res) {
            throw new Exception("Write failure.");
        }
    }

    public function getMd5Array()
    {
        require_once 'include/utils/file_utils.php';
        $ignoreDirs = array('cache', 'upload', '.git');
        $md5arr = generateMD5array('./', $ignoreDirs);

        $ignorePaths = array();
        if(file_exists('.spmignore')) {
            $ignorePaths = array_merge($ignorePaths, file('.spmignore', FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES));
        }
        if(file_exists('.gitmodules')) {
            $submodules = parse_ini_file('.gitmodules', true);
            foreach($submodules as $mod) {
                $ignorePaths[] = $mod['path'].'/*';
            }
        }

        $md5arrFiltered = array();
        foreach($md5arr as $filename => $md5) {
            if(substr($filename, 0, 2) == './') {
                $filename1 = substr($filename, 2);
            }

            $ignore = false;
            foreach($ignorePaths as $mask) {
                if(fnmatch($mask, $filename1)) {
                    $ignore = true;
                    break;
                }
            }
            if($ignore) {
                continue;
            }

            $md5arrFiltered[$filename1] = $md5;
        }

        $gitIgnoreFiles = array();
        $descriptorspec = array(
            0 => array("pipe", "r"),
            1 => array("pipe", "w"),
        );
        $gitIgnoreProc = proc_open('git check-ignore --stdin', $descriptorspec, $pipes);
        if (is_resource($gitIgnoreProc)) {
            foreach($md5arrFiltered as $filename => $md5) {
                fwrite($pipes[0], $filename);
                fwrite($pipes[0], PHP_EOL);
            }
            fclose($pipes[0]);
            while($line = fgets($pipes[1])) {
                $gitIgnoreFiles[trim($line)] = 1;
            }
            fclose($pipes[1]);
            proc_close($gitIgnoreProc);
        }

        return array_diff_key($md5arrFiltered, $gitIgnoreFiles);
    }

    public function md5Compare($file1, $file2 = null)
    {
        if(!is_file($file1)) {
            throw new Exception("File $file1 not exists");
        }
        if($file2 && !is_file($file2)) {
            throw new Exception("File $file2 not exists");
        }

        $md5_string_calculated = null;
        $md5_string = null;
        require $file1;
        if(is_array($md5_string_calculated)) {
            $md5_array1 = $md5_string_calculated;
        }
        elseif(is_array($md5_string)) {
            $md5_array1 = $md5_string;
        }
        else {
            throw new Exception("Error on getting first array.");
        }

        if(is_file($file2)) {
            $md5_string_calculated = null;
            $md5_string = null;
            require $file2;
            if(is_array($md5_string_calculated)) {
                $md5_array2 = $md5_string_calculated;
            }
            elseif(is_array($md5_string)) {
                $md5_array2 = $md5_string;
            }
            else {
                throw new Exception("Error on getting second array.");
            }
        }
        else {
            $md5_array2 = $this->getMd5Array();
            $file2 = 'current';
        }

        $diff = array_diff(array_keys($md5_array2), array_keys($md5_array1));
        if($diff) {
            echo "New files (in $file2, but not in $file1):\n";
            echo "  ",implode("\n  ", $diff),"\n";
        }

        $diff = array_diff(array_keys($md5_array1), array_keys($md5_array2));
        if($diff) {
            echo "Deleted files (in $file1, but not in $file2):\n";
            echo "  ",implode("\n  ", $diff),"\n";
        }

        $diff = array_diff_assoc(array_intersect_key($md5_array1, $md5_array2), array_intersect_key($md5_array2, $md5_array1));
        if($diff) {
            echo "Modified files:\n";
            echo "  ",implode("\n  ", array_keys($diff)),"\n";
        }
    }
}

/**
 * Dummy used when sqlite is unavailable
 * UpdateStage supported only
 */
class SpmPDO
{
    public $lastException;
    public $spm;

    public function query($statement) {
        throw $this->lastException;
    }

    public function quote($string) {
        throw $this->lastException;
    }

    public function exec($statement)
    {
        if(in_array($statement, array(
              "DROP TABLE IF EXISTS stage"
            , "CREATE TABLE stage (id_name TEXT COLLATE NOCASE, version TEXT, filename TEXT, type TEXT)"
            , "DROP TABLE IF EXISTS available"
            , "CREATE TABLE available (id_name TEXT COLLATE NOCASE, version TEXT, filename TEXT)"
        ))) {
            return;
        }
        throw $this->lastException;
    }

    public function prepare($statement, $driver_options = array())
    {
        if($statement == "INSERT INTO stage (id_name, version, filename, type) VALUES (:id_name, :version, :filename, :type)") {
            return new DummyStatement();
        }
        if($statement == SelectFromStageStatement::STATEMENT) {
            $stmt = new SelectFromStageStatement();
            $stmt->spm = $this->spm;
            return $stmt;
        }
        if($statement == SelectOneFromStageStatement::STATEMENT) {
            $stmt = new SelectOneFromStageStatement();
            $stmt->spm = $this->spm;
            return $stmt;
        }
        if($statement == "INSERT INTO available (id_name, version, filename) VALUES (:id_name, :version, :filename)") {
            return new DummyStatement();
        }
        if($statement == SelectFromAvailableStatement::STATEMENT) {
            $stmt = new SelectFromAvailableStatement();
            $stmt->spm = $this->spm;
            return $stmt;
        }
        throw $this->lastException;
    }
}

/**
 * Dummy used when sqlite is unavailable.
 * Do nothing.
 */
class DummyStatement
{
    public $spm;
    public $params = array();

    public function bindParam($parameter, &$variable) {
        $this->params[$parameter] = $variable;
    }

    public function execute($input_parameters = array()) {
        $this->params = array_merge($this->params, $input_parameters);
    }
}
/**
 * Dummy used to update stage when sqlite is unavailable
 */
class SelectFromStageStatement extends DummyStatement
{
    const STATEMENT = "SELECT id_name, version, filename, type FROM stage WHERE id_name = :id_name AND (version = :version OR :version IS NULL) ORDER BY version COLLATE NATURAL_CMP DESC";

    public function fetchAll()
    {
        $result = array();
        foreach($this->spm->packagesInStaging as $pack) {
            $id = $pack['id_name'];
            $version = $pack['version'];
            if($id != $this->params[':id_name'] || ($this->params[':version'] !== null && $version != $this->params[':version'])) {
                continue;
            }
            $result[$version] = $pack;
        }
        uksort($result, "strnatcmp");
        $result = array_reverse($result);
        return $result;
    }
}
class SelectOneFromStageStatement extends DummyStatement
{
    const STATEMENT = "SELECT 1 FROM stage WHERE id_name = :id_name AND version = :version LIMIT 1";

    public function fetchAll()
    {
        $result = array();
        foreach($this->spm->packagesInStaging as $pack) {
            $id = $pack['id_name'];
            $version = $pack['version'];
            if($id != $this->params[':id_name'] || ($this->params[':version'] !== null && $version != $this->params[':version'])) {
                continue;
            }
            $result[] = array('1' => 1);
        }
        return $result;
    }
}
class SelectFromAvailableStatement extends DummyStatement
{
    const STATEMENT = "SELECT version, filename FROM available WHERE id_name = :id_name AND (version = :version OR :version IS NULL) ORDER BY version COLLATE NATURAL_CMP DESC LIMIT 1";

    public function fetch()
    {
        $result = array();
        foreach($this->spm->packagesAvailable as $pack) {
            $id = $pack['id_name'];
            $version = $pack['version'];
            if($id != $this->params[':id_name'] || ($this->params[':version'] !== null && $version != $this->params[':version'])) {
                continue;
            }
            $result[$version] = $pack;
        }
        uksort($result, "strnatcmp");
        $result = array_reverse($result);
        if(!empty($result)) {
            return reset($result);
        }
        return null;
    }
}

class DependenciesException extends Exception {
}

class FileAlreadyExistsException extends Exception {
}

class SpmCmd
{
    protected $spm;

    public function __construct()
    {
        $this->spm = new Spm();
        $this->spm->cwd = getcwd();
    }

    public static function getCmdFromCli()
    {
        global $argv;
        if(isset($argv[1])) {
            $cmdClass = 'SpmCmd'.implode('', array_map('ucfirst', explode('-', strtolower($argv[1]))));
            if(class_exists($cmdClass)) {
                return new $cmdClass;
            }
        }
        return null;
    }

    protected function getArgvParams($subjectCount, $allowedOptions)
    {
        global $argv;
        $options = array();
        $subjects = array();
        for($i = 2; $i < count($argv); $i++) {
            if($argv[$i][0] == '-') {
                $optPair = explode("=", ltrim($argv[$i], '-'));
                $name = $optPair[0];
                if(in_array($name.':', $allowedOptions)) {
                    if(count($optPair) < 2) {
                        throw new Exception("Value must be specified for option {$argv[$i]}");
                    }
                    $options[$name] = $optPair[1];
                }
                elseif(in_array($name, $allowedOptions)) {
                    $options[$name] = true;
                }
                else {
                    throw new Exception("Unknown option {$argv[$i]}");
                }
            }
            else {
                if($subjectCount !== false && count($subjects) >= $subjectCount) {
                    throw new Exception("Unknown option {$argv[$i]}");
                }
                $subjects[] = $argv[$i];
            }
        }
        if($subjectCount !== false && count($subjects) < $subjectCount) {
            throw new Exception("Some params are missing. See `spm help`.");
        }
        return array($subjects, $options);
    }

    public static function optionsToString($allowedOptions, $options)
    {
        $str = '';
        foreach($options as $name => $value) {
            if(in_array($name.':', $allowedOptions)) {
                $str .= " --$name=\"$value\"";
            }
            elseif(in_array($name, $allowedOptions)) {
                $str .= " --$name";
            }
        }
        return $str;
    }

    protected static function parsePackageName($fullname)
    {
        if(preg_match("#^(.+)\-(.*[0-9].*)$#", $fullname, $matches)) {
            return array($matches[1], $matches[2]);
        }
        return array($fullname, null);
    }
}

class SpmCmdVersion extends SpmCmd
{
    public function executeNonSugar()
    {
        global $sugar_config;
        echo "Spm: ".SPM_VERSION."\n";
        if(is_file('manifest.php')) {
            $manifest = null;
            $installdefs = null;
            include 'manifest.php';
            if(!empty($manifest['version']) && !empty($installdefs['id'])) {
                echo "{$installdefs['id']}: {$manifest['version']}\n";
            }
        }
        if(Spm::enterSugar()) {
            if(!empty($sugar_config['sugar_version'])) {
                echo "SugarCRM: {$sugar_config['sugar_version']}\n";
            }
            if(!empty($sugar_config['suitecrm_version'])) {
                echo "SuiteCRM: {$sugar_config['suitecrm_version']}\n";
            }
            Spm::cleanupSugar();
        }
    }
}

class SpmCmdList extends SpmCmd
{
    public function executeNonSugar()
    {
        list($keywords, $options) = self::getArgvParams(false, array('a', 'spm-path:', 'each-version'));
        if(!empty($options['a'])) {
            echo "Available:\n";
            $this->spm->updateAvailable($options);
            $this->spm->listAvailable(empty($keywords) ? null : reset($keywords), $options);
        }
    }

    public function execute()
    {
        list($keywords, $options) = self::getArgvParams(false, array('a', 'spm-path:', 'each-version'));
        echo "Installed:\n";
        $this->spm->listInstalled(empty($keywords) ? null : reset($keywords), $options);
        echo "Loaded:\n";
        $this->spm->updateStage();
        $this->spm->listLoaded(empty($keywords) ? null : reset($keywords), $options);
    }
}

class SpmCmdCheck extends SpmCmd
{
    public function execute()
    {
        list($subjects, $options) = self::getArgvParams(false, array('by-restore', 'a', 'modified'));
        if(!empty($options['by-restore'])) {
            $this->spm->listRestoreConflicts();
        }
        $this->spm->updateCopiedFiles();
        $this->spm->updatePackagesOverwrites();
        $this->spm->check(!empty($options['a']));
        if(!empty($options['modified'])) {
            $this->spm->checkModified();
        }
    }
}

class SpmCmdInstall extends SpmCmd
{
    public static $ALLOWED_OPTIONS = array(
        'no-copy',
        'lock-file:',
        'log-file:',
    );

    public function execute()
    {
        list($packages, $options) = self::getArgvParams(1, self::$ALLOWED_OPTIONS);
        list($id_name, $version) = self::parsePackageName(reset($packages));
        $this->spm->updateStage();
        $this->spm->install($id_name, $version, $options);
    }
}

class SpmCmdUninstall extends SpmCmd
{
    public static $ALLOWED_OPTIONS = array(
        'remove-tables',
        'remove-acl',
        'remove-custom',
        'remove-prefs',
        'remove-relationships',
        'not-uninstallable',
        'no-copy',
        'lock-file:',
        'log-file:',
    );

    public function execute()
    {
        list($packages, $options) = self::getArgvParams(1, self::$ALLOWED_OPTIONS);
        list($id_name, $version) = self::parsePackageName(reset($packages));
        $this->spm->uninstall($id_name, $version, $options);
    }
}

class SpmCmdRemove extends SpmCmd
{
    public function execute()
    {
        list($packages, $options) = self::getArgvParams(1, array());
        list($id_name, $version) = self::parsePackageName(reset($packages));
        $this->spm->updateStage();
        $this->spm->remove($id_name, $version);
    }
}

class SpmCmdUpload extends SpmCmd
{
    public function execute()
    {
        list($packages, $options) = self::getArgvParams(1, array('no-php-check', 'spm-path:'));
        list($id_name, $version) = self::parsePackageName(reset($packages));
        $this->spm->updateAvailable($options);
        $this->spm->upload($id_name, $version, $options);
    }
}

class SpmCmdZip extends SpmCmd
{
    public function executeNonSugar()
    {
        list($packages, $options) = self::getArgvParams(1, array('no-php-check', 'spm-path:'));
        list($id_name, $version) = self::parsePackageName(reset($packages));
        $this->spm->updateAvailable($options);
        $this->spm->zip($id_name, $version, $options);
    }
}

class SpmCmdRepair extends SpmCmd
{
    public function execute()
    {
        list($subjects, $options) = self::getArgvParams(false, array('v'));
        $this->spm->repair($options);
    }
}

class SpmCmdDbquery extends SpmCmd
{
    public function execute()
    {
        list($subjects, $options) = self::getArgvParams(false, array('s', 'f'));
        if(count($subjects) > 1) {
            array_shift($subjects);
            throw new Exception("Unknown option ".implode(' ', $subjects));
        }
        if(empty($subjects)) {
            $sql = '';
            while($line = fgets(STDIN)) {
              $sql .= $line."\n";
            }
        }
        else {
            $sql = reset($subjects);
        }
        $allowedQueries = null;
        if(file_exists('.spmqueries.php')) {
            $allowedQueries = require '.spmqueries.php';
            if(!is_array($allowedQueries)) {
                throw new Exception('.spmqueries.php must return array');
            }
        }
        if($allowedQueries === null) {
            if(!empty($options['s'])) {
                throw new Exception(".spmqueries.php not exists but its option 's' defined");
            }
            if(!empty($options['f'])) {
                throw new Exception(".spmqueries.php not exists but its option 'f' defined");
            }
        }
        if(!empty($options['s']) && !empty($options['f'])) {
            throw new Exception("Options 's' and 'f' can not be used concurrently");
        }
        echo "Checking .spmqueries.php file: ".($allowedQueries === null ? "not exists - queries will not be checked with whitelist" : "exists")."\n";
        $this->spm->dbquery($sql, $allowedQueries, $options);
    }
}

class SpmCmdCreate extends SpmCmd
{
    public function executeNonSugar()
    {
        $spm_home_dir = $_SERVER['HOME'].'/.spm';
        echo "Package structure will be created in this directory.\n";

        $defaultName = basename(getcwd());
        echo "Input name of new package [$defaultName]: ";
        $id_name = ($s = trim(fgets(STDIN))) ? $s : $defaultName;

        $defaultAuthor = file_exists($spm_home_dir.'/last_author')
            ? file_get_contents($spm_home_dir.'/last_author') : get_current_user();
        echo "Input author name [$defaultAuthor]: ";
        $author = ($s = trim(fgets(STDIN))) ? $s : $defaultAuthor;

        echo "Input description: ";
        $description = trim(fgets(STDIN));

        $licensesDir = $spm_home_dir.'/licenses';
        do {
            echo "Choose license among txt files in $licensesDir [n]:\n";
            $licensesFiles = glob($licensesDir."/*.txt");
            echo " n) none\n";
            echo " r) rescan directory\n";
            foreach($licensesFiles as $i => $file) {
                echo " ".($i+1).") ".basename($file)."\n";
            }
            $answer = trim(fgets(STDIN));
            $done = false;
            if($answer == 'n' || $answer === '') {
                $license = false;
                $done = true;
            }
            elseif(is_numeric($answer) && isset($licensesFiles[$answer - 1])) {
                $license = $licensesFiles[$answer - 1];
                $done = true;
            }
        }
        while(!$done);

        $publishedDate = date('Y-m-d');
        $id_name_quoted = var_export($id_name, true);
        $description_quoted = var_export($description, true);
        $author_quoted = var_export($author, true);

        echo "Creating manifest.php ...\n";
        if(file_exists('manifest.php')) {
            echo "Error: manifest.php already exists.\n";
        }
        else {
            file_put_contents('manifest.php', <<<MANIFEST
<?php
\$manifest = array(
    'name' => $id_name_quoted,
    'acceptable_sugar_versions' => array(),
    'acceptable_sugar_flavors' => array('CE'),
    'author' => $author_quoted,
    'description' => $description_quoted,
    'is_uninstallable' => true,
    'published_date' => '$publishedDate',
    'type' => 'module',
    'version' => '1.0.0',
);
\$installdefs = array(
    'id' => '$id_name',
    'copy' => array(
        array(
            'from' => '<basepath>/source/copy',
            'to' => '.'
        ),
    ),
);

MANIFEST
);
            if(is_dir($spm_home_dir)) {
                file_put_contents($spm_home_dir.'/last_author', $author);
            }
        }

        echo "Creating source directory ...\n";
        if(file_exists('source')) {
            echo "Error: source already exists.\n";
        }
        else {
            mkdir('source');
            mkdir('source/copy');
        }

        echo "Creating README.txt ...\n";
        if(file_exists('README.txt')) {
            echo "Error: README.txt already exists.\n";
        }
        else {
            touch('README.txt');
            file_put_contents('README.txt', $description."\n");
        }

        echo "Creating LICENSE.txt ...\n";
        if(file_exists('LICENSE.txt')) {
            echo "Error: LICENSE.txt already exists.\n";
        }
        else {
            if($license) {
                copy($license, 'LICENSE.txt');
            }
            else {
                touch('LICENSE.txt');
            }
        }
    }
}

class SpmCmdFile extends SpmCmd
{
    public function execute()
    {
        list($files, $options) = self::getArgvParams(false, array(
            'sync',
            'spm-path:',
        ));
        $sugarDir = getcwd();
        chdir($this->spm->cwd);
        $realFiles = array();
        if(empty($files)) {
            throw new Exception("You must specify a file");
        }
        $wrongFiles = array();
        foreach($files as $file) {
            $fullpath = realpath($file);
            if(!$fullpath) {
                $fullpath = $this->spm->cwd.'/'.$file;
            }
            if(file_exists($fullpath)) {
                $realFiles[] = $fullpath;
            }
            else {
                $wrongFiles[] = $fullpath;
                echo "File $file not found.\n";
            }
        }
        chdir($sugarDir);
        if(empty($realFiles)) {
            return;
        }
        $this->spm->updateCopiedFiles();
        $this->spm->updatePackagesOverwrites();

        if(!empty($options['sync'])) {
            $syncedFiles = array();
            $this->spm->updateAvailable($options);
            $realFiles = array_unique($realFiles);
            foreach($realFiles as $file) {
                $path = ltrim(substr($file, strlen(getcwd())), '/');
                $md5 = md5_file($path);
                echo "\n{$path}:\n";
                $variants = $this->spm->searchFileInAvailable($path);
                $variants = array_values($variants);
                if(!empty($variants)) {
                    $quit = false;
                    $done = false;
                    do {
                        foreach($variants as $i => $var) {
                            $varMd5 = md5_file($var['path']);
                            echo "  ".($i+1).") Rewrite {$var['info']['type']} {$var['path']}".($md5 === $varMd5 ? " (not modified)" : " (modified)")."\n";
                        }
                        echo "  s) Skip this file\n";
                        echo "  q) Quit\n";
                        $answer = trim(fgets(STDIN));
                        if($answer == 's') {
                            $done = true;
                        }
                        elseif($answer == 'q') {
                            $quit = true;
                        }
                        elseif(is_numeric($answer) && isset($variants[$answer - 1])) {
                            $file_to = $variants[$answer - 1]['path'];
                            echo "Rewrite {$file_to} with {$file} ...";
                            if(copy($file, $file_to)) {
                                $syncedFiles[] = $file;
                                echo " Ok\n";
                                $done = true;
                            }
                            else {
                                echo " FAIL\n";
                            }
                        }
                        if(!$done && !$quit) {
                            echo "Please repeat\n";
                        }
                    }
                    while(!$done && !$quit);

                    if($quit) {
                        break;
                    }
                }
                else {
                    echo "  No package found\n";
                }
            }
            if(!empty($syncedFiles)) {
                echo "\nSynchronized files:\n\n";
                foreach($syncedFiles as $file) {
                    echo "  $file\n";
                }
                echo "\nSkipped files:\n\n";
                foreach(array_diff($realFiles, $syncedFiles) as $file) {
                    echo "  $file\n";
                }
                foreach($wrongFiles as $file) {
                    echo "  $file\n";
                }
                echo "\nDone\n";
            }
            else {
                echo "\nNo changes was made.\n";
            }
            return;
        }

        foreach($realFiles as $file) {
            $path = ltrim(substr($file, strlen(getcwd())), '/');
            $fileInfo = $this->spm->getFileInfo($path);
            $this->spm->listFileInfo($fileInfo);
        }
    }
}

class SpmCmdSandboxInit extends SpmCmd
{
    public function execute()
    {
        list($x, $options) = self::getArgvParams(0, array('no-merge'));
        $this->spm->sandboxInit($options);
    }
}

class SpmCmdSbinit extends SpmCmdSandboxInit {
}

class SpmCmdSandboxStatus extends SpmCmd
{
    public function execute()
    {
        list($environments, $options) = self::getArgvParams(false, array('file:', 'input'));
        if(!empty($options['file']) && !empty($options['input'])) {
            throw new Exception("Options conflict: file and input");
        }
        $this->spm->sandboxStatus($environments, $options);
    }
}

class SpmCmdSbstatus extends SpmCmdSandboxStatus {
}

class SpmCmdSandboxInstall extends SpmCmd
{
    public function execute()
    {
        $allowedOptions = array('file:', 'no-uninstall', 'input');
        $allowedOptions = array_merge($allowedOptions, SpmCmdInstall::$ALLOWED_OPTIONS);
        $allowedOptions = array_merge($allowedOptions, SpmCmdUninstall::$ALLOWED_OPTIONS);
        list($environments, $options) = self::getArgvParams(false, $allowedOptions);
        if(!empty($options['file']) && !empty($options['input'])) {
            throw new Exception("Options conflict: file and input");
        }
        $this->spm->sandboxInstall($environments, $options);
    }
}

class SpmCmdSbinstall extends SpmCmdSandboxInstall {
}

class SpmCmdMd5Generate extends SpmCmd
{
    public function execute()
    {
        list($files, $options) = self::getArgvParams(false, array());
        if(count($files) > 1) {
            array_shift($files);
            throw new Exception("Unknown option ".implode(' ', $files));
        }

        $sugarDir = getcwd();
        chdir($this->spm->cwd);
        if(!empty($files)) {
            $file = reset($files);
            $pathinfo = pathinfo($file);
            $dirpath = realpath($pathinfo['dirname']);
            if(!$dirpath) {
                throw new Exception("Directory {$pathinfo['dirname']} not exists.");
            }
            $file = $dirpath.'/'.$pathinfo['basename'];
        }
        else {
            $i = 0;
            do {
                $file = $this->spm->cwd."/md5_array_calculated-".date('Y-m-d').($i ? "($i)" : "").".php";
                $i++;
            }
            while(file_exists($file));
        }
        chdir($sugarDir);
        $this->spm->md5Generate($file);
    }
}

class SpmCmdMd5Compare extends SpmCmd
{
    public function execute()
    {
        list($files, $options) = self::getArgvParams(false, array());
        if(count($files) > 2) {
            array_shift($files);
            array_shift($files);
            throw new Exception("Unknown option ".implode(' ', $files));
        }
        if(empty($files)) {
            throw new Exception("At least one file must be specified");
        }
        $sugarDir = getcwd();
        chdir($this->spm->cwd);
        foreach($files as $key => $file) {
            if(!($files[$key] = realpath($file))) {
                throw new Exception("File {$file} not exists.");
            }
        }
        chdir($sugarDir);
        $this->spm->md5Compare($files[0], isset($files[1]) ? $files[1] : null);
    }
}

if(!defined('SUGARCRM_PRE_INSTALL_FILE'))
{
    define('SUGARCRM_PRE_INSTALL_FILE', 'scripts/pre_install.php');
    define('SUGARCRM_POST_INSTALL_FILE', 'scripts/post_install.php');
    define('SUGARCRM_PRE_UNINSTALL_FILE', 'scripts/pre_uninstall.php');
    define('SUGARCRM_POST_UNINSTALL_FILE', 'scripts/post_uninstall.php');
}
$cmd = SpmCmd::getCmdFromCli();
if(!$cmd) {
    echo "Unknown command. Run `spm help`.\n";
    exit(2);
}
if(method_exists($cmd, 'executeNonSugar')) {
    try {
        $cmd->executeNonSugar();
    }
    catch (Exception $e) {
        echo $e->getMessage(),"\n";
        exit(3);
    }
}
if(!method_exists($cmd, 'execute')) {
    exit;
}
if(!Spm::enterSugar()) {
    echo "SugarCRM root not found.\n";
    exit(4);
}

require_once('ModuleInstall/PackageManager/PackageManager.php');
class SpmPackageManager extends PackageManager
{
    public $options = array();
    private $cleanUpDirs = array();

    private function addToCleanup($dir)
    {
        if(empty($this->cleanUpDirs)) {
            register_shutdown_function(array($this, "cleanUpTempDir"));
        }
        $this->cleanUpDirs[] = $dir;
    }

    public function cleanUpTempDir()
    {
        foreach($this->cleanUpDirs as $dir) {
            rmdir_recursive($dir);
        }
    }

    /**
     * Добавлен запуск pre/post_install, dependencies
     */
    function performInstall($file, $silent=true){
        global $sugar_config;
        global $mod_strings;
        global $current_language;
        $base_upgrade_dir       = $this->upload_dir.'/upgrades';
        $base_tmp_upgrade_dir   = "$base_upgrade_dir/temp";
        if(!file_exists($base_tmp_upgrade_dir)){
            mkdir_recursive($base_tmp_upgrade_dir, true);
        }

        $GLOBALS['log']->debug("INSTALLING: ".$file);
        $mi = new ModuleInstaller();
        $mi->silent = $silent;
             $GLOBALS['log']->debug("ABOUT TO INSTALL: ".$file);
        if(preg_match("#.*\.zip\$#", $file)) {
             $GLOBALS['log']->debug("1: ".$file);
            // handle manifest.php
            $target_manifest = remove_file_extension( $file ) . '-manifest.php';
            $dependencies = array();
            $installdefs = array();
            include($target_manifest);
            if(!empty($manifest['dependencies'])) {
                $dependencies = $manifest['dependencies'];
            }
            $GLOBALS['log']->debug("2: ".$file);
            $unzip_dir = mk_temp_dir( $base_tmp_upgrade_dir );
            $this->addToCleanup($unzip_dir);
            unzip($file, $unzip_dir );
            $GLOBALS['log']->debug("3: ".$unzip_dir);
            $id_name = $installdefs['id'];
			$version = $manifest['version'];
			$type = $manifest['type'];
			$uh = new UpgradeHistory();
            //check dependencies first
            if(!empty($dependencies)) {
                $not_found = $uh->checkDependencies($dependencies);
                if(!empty($not_found) && count($not_found) > 0){
                    throw new DependenciesException( $mod_strings['ERR_UW_NO_DEPENDENCY']."[".implode(',', $not_found)."]");
                }
            }
			$previous_install = array();
    		if(!empty($id_name) & !empty($version))
    			$previous_install = $uh->determineIfUpgrade($id_name, $version);
    		$previous_version = (empty($previous_install['version'])) ? '' : $previous_install['version'];
    		$previous_id = (empty($previous_install['id'])) ? '' : $previous_install['id'];

            $preInstallFile = "$unzip_dir/" . constant('SUGARCRM_PRE_INSTALL_FILE');
            if(is_file($preInstallFile)) {
                echo "{$mod_strings['LBL_UW_INCLUDING']}: $preInstallFile\n";
                include($preInstallFile);
                pre_install();
            }

            if(empty($this->options['no-copy'])) {
                if(!empty($previous_version)){
                    $mi->install($unzip_dir, true, $previous_version);
                }else{
                    $mi->install($unzip_dir);
                }
            }
            else {
                if(isset($installdefs['beans'])){
                    foreach($installdefs['beans'] as $bean){
                        if(!empty($bean['module']) && !empty($bean['class']) && !empty($bean['path'])){
                            $module = $bean['module'];
                            if($bean['tab']){
                                $tab_modules[] = $module;
                                UpdateSystemTabs('Add', $tab_modules);
                            }
                        }
                    }
                }
                //TODO: run pre_execute, post_execute
            }

            if($type == 'langpack') {
                $langInfo = $this->getLangInfo($manifest, $unzip_dir);
                $sugar_config['languages'] = $sugar_config['languages'] + $langInfo;
                ksort( $sugar_config );
                if( !write_array_to_file( "sugar_config", $sugar_config, "config.php" ) ){
                    throw new Exception($mod_strings['ERR_UW_CONFIG_FAILED']);
                }
            }

            $postInstallFile = "$unzip_dir/" . constant('SUGARCRM_POST_INSTALL_FILE');
            if(is_file($postInstallFile))
            {
                echo "{$mod_strings['LBL_UW_INCLUDING']}: $postInstallFile\n";
                include($postInstallFile);
                post_install();
            }

            $GLOBALS['log']->debug("INSTALLED: ".$file);
            $new_upgrade = new UpgradeHistory();
            $new_upgrade->filename      = $file;
            $new_upgrade->md5sum        = md5_file($file);
            $new_upgrade->type          = $manifest['type'];
            $new_upgrade->version       = $manifest['version'];
            $new_upgrade->status        = "installed";
            //$new_upgrade->author        = $manifest['author'];
            $new_upgrade->name          = $manifest['name'];
            $new_upgrade->description   = $manifest['description'];
            $new_upgrade->id_name		= $id_name;
			$serial_manifest = array();
			$serial_manifest['manifest'] = (isset($manifest) ? $manifest : '');
			$serial_manifest['installdefs'] = (isset($installdefs) ? $installdefs : '');
			$serial_manifest['upgrade_manifest'] = (isset($upgrade_manifest) ? $upgrade_manifest : '');
			$new_upgrade->manifest		= base64_encode(serialize($serial_manifest));
            //$new_upgrade->unique_key    = (isset($manifest['unique_key'])) ? $manifest['unique_key'] : '';
            $new_upgrade->save();
                    //unlink($file);
        }//fi
    }

    function performUninstall($name, $version){
    	$uh = new SpmUpgradeHistory(); // overridden
    	$uh->name = $name;
    	$uh->id_name = $name;
    	$uh->version = $version;
    	$found = $uh->checkForExisting($uh);
    	if($found != null){
    		global $sugar_config;
	        global $mod_strings;
	        global $current_language;
	        $base_upgrade_dir       = $this->upload_dir.'/upgrades';
	        $base_tmp_upgrade_dir   = "$base_upgrade_dir/temp";
            if(is_file($found->filename)){
                $hash = md5($found->filename);
                $_SESSION['file2Hash'][$hash] = $found->filename;
                $_REQUEST['install_file'] = $hash; // used in ModuleInstaller
                if(!isset($GLOBALS['mi_remove_tables']))$GLOBALS['mi_remove_tables'] = true;
                $unzip_dir = mk_temp_dir( $base_tmp_upgrade_dir );
                unzip($found->filename, $unzip_dir );
                register_shutdown_function("rmdir_recursive", $unzip_dir);
                $mi = new SpmModuleInstaller();
                $mi->options = $this->options;
                $mi->silent = true;

                $preUninstallFile = "$unzip_dir/" . constant('SUGARCRM_PRE_UNINSTALL_FILE');
                if(is_file($preUninstallFile))
                {
                    echo "{$mod_strings['LBL_UW_INCLUDING']}: $preUninstallFile\n";
                    include($preUninstallFile);
                    pre_uninstall();
                }

                if(empty($this->options['no-copy'])) {
                    $mi->uninstall( "$unzip_dir");
                }
                //TODO: restore sytem tabs

                if($found->type == 'langpack') {
                    $langInfo = $this->getLangInfo(array(), $unzip_dir); //TODO: manifest
                    reset($langInfo);
                    $new_lang_name = key($langInfo);
                    $new_langs = array();
                    $old_langs = $sugar_config['languages'];
                    foreach( $old_langs as $key => $value ){
                        if( $key != $new_lang_name ){
                            $new_langs += array( $key => $value );
                        }
                    }
                    $sugar_config['languages'] = $new_langs;
                    $default_sugar_instance_lang = 'en_us';
                    if($sugar_config['default_language'] == $new_lang_name){
                        $cfg = new Configurator();
                        $cfg->config['languages'] = $new_langs;
                        $cfg->config['default_language'] = $default_sugar_instance_lang;
                        $cfg->handleOverride();
                    }
                    ksort( $sugar_config );
                    if( !write_array_to_file( "sugar_config", $sugar_config, "config.php" ) ){
                        throw new Exception($mod_strings['ERR_UW_CONFIG_FAILED']);
                    }
                }

                $found->delete();
                //unlink(remove_file_extension( $found->filename ) . '-manifest.php');
                //unlink($found->filename);
                unset($_SESSION['file2Hash'][$hash]);
            }else{
                echo "Warning: file {$found->filename} not found. Just deleting from upgrade_history.\n";
                //file(s_ have been deleted or are not found in the directory, allow database delete to happen but no need to change filesystem
                $found->delete();
            }
    	}
        else {
            throw new Exception("Рackage not found");
        }
    }

    /**
     * modules/Administration/UpgradeWizard_prepare.php
     */
    protected function getLangInfo($manifest, $unzip_dir) {
        $zip_from_dir = ".";
        if( isset( $manifest['copy_files']['from_dir'] ) && $manifest['copy_files']['from_dir'] != "" ){
            $zip_from_dir   = $manifest['copy_files']['from_dir'];
        }
        // find name of language pack: find single file in include/language/xx_xx.lang.php
        $d = dir( "$unzip_dir/$zip_from_dir/include/language" );
        while( $f = $d->read() ){
            if( $f == "." || $f == ".." ){
                continue;
            }
            else if( preg_match("/(.*)\.lang\.php\$/", $f, $match) ){
                $new_lang_name = $match[1];
            }
        }
        if( $new_lang_name == "" ){
            throw new Exception("Can't find name of language pack ".$install_file);
        }

        $new_lang_desc = $this->getLanguagePackName( "$unzip_dir/$zip_from_dir/include/language/$new_lang_name.lang.php" );
        if( $new_lang_desc == "" ){
            throw new Exception("Can't find description of language pack include/language/$new_lang_name.lang.php");
        }

        return array($new_lang_name => $new_lang_desc);
    }

    /**
     * modules/Administration/UpgradeWizardCommon.php
     */
    protected function getLanguagePackName( $the_file ){
        global $app_list_strings;
        require_once( "$the_file" );
        if( isset( $app_list_strings["language_pack_name"] ) ){
            return( $app_list_strings["language_pack_name"] );
        }
        return( "" );
    }
}

require_once('modules/Administration/UpgradeHistory.php');
class SpmUpgradeHistory extends UpgradeHistory
{
    function checkForExisting($patch_to_check){
        $uh = new UpgradeHistory();
        if($patch_to_check != null){

            if(empty($patch_to_check->id_name)){
                $where = " WHERE name = '$patch_to_check->name' ";
            }else{
                $where = " WHERE id_name = '$patch_to_check->id_name' ";
            }

            if(!empty($patch_to_check->id)){
                $where .= "  AND id != '$patch_to_check->id'  ";
            }else{
                $where .= "  AND id is not null  ";
            }

            if(!empty($patch_to_check->version)){ // version added
                $where .= " AND version = '$patch_to_check->version' ";
            }

            $query = "SELECT id FROM " . $this->table_name . " ". $where;

            $result = $uh->db->query($query);
            if(empty($result)){
                return null;
            }
            $row = $uh->db->fetchByAssoc($result);
            if(empty($row)){
                return null;
            }
            if(!empty($row['id'])){
                return $uh->retrieve($row['id']);
            }
        }
        return null;
    }
}

require_once('ModuleInstall/ModuleInstaller.php');
class SpmModuleInstaller extends ModuleInstaller
{
    public $options;

    public function remove_acl_actions()
    {
        if(!empty($this->options['remove-acl'])) {
            parent::remove_acl_actions();
        }
    }

    public function uninstall_customizations($beans)
    {
        if(!empty($this->options['remove-custom'])) {
            parent::uninstall_customizations($beans);
        }
    }

    public function uninstall_user_prefs($module)
    {
        if(!empty($this->options['remove-prefs'])) {
            parent::uninstall_user_prefs($module);
        }
    }

    public function uninstall_relationships($include_studio_relationships = false)
    {
        if(!empty($this->options['remove-relationships'])) {
            parent::uninstall_relationships($include_studio_relationships); //здесь из форм связанных модулей удаляются ссылки на модуль
        }
    }

    /**
     * Исправлена ошибка с удалением файлов, если они копировались в одну папку.
     */
    public function uninstall_copy(){
		if(!empty($this->installdefs['copy'])){
					foreach($this->installdefs['copy'] as $cp){
						$cp['to'] = clean_path(str_replace('<basepath>', $this->base_dir, $cp['to']));
						$cp['from'] = clean_path(str_replace('<basepath>', $this->base_dir, $cp['from']));
						$GLOBALS['log']->debug('Unlink ' . $cp['to']);
				/* BEGIN - RESTORE POINT - by MR. MILK August 31, 2005 02:22:11 PM */
						//rmdir_recursive($cp['to']);

						$backup_path = clean_path( remove_file_extension(urldecode(hashToFile($_REQUEST['install_file'])))."-restore/".$cp['to'] );
						$this->uninstall_new_files($cp, $backup_path); //PEA: here uninstall all files
						//$this->copy_path($backup_path, $cp['to'], $backup_path, true);
				/* END - RESTORE POINT - by MR. MILK August 31, 2005 02:22:18 PM */
					}
					foreach($this->installdefs['copy'] as $cp){
						$cp['to'] = clean_path(str_replace('<basepath>', $this->base_dir, $cp['to']));
						$cp['from'] = clean_path(str_replace('<basepath>', $this->base_dir, $cp['from']));
						$GLOBALS['log']->debug('Unlink ' . $cp['to']);
				/* BEGIN - RESTORE POINT - by MR. MILK August 31, 2005 02:22:11 PM */
						//rmdir_recursive($cp['to']);

						$backup_path = clean_path( remove_file_extension(urldecode(hashToFile($_REQUEST['install_file'])))."-restore/".$cp['to'] );
						//$this->uninstall_new_files($cp, $backup_path);
						$this->copy_path($backup_path, $cp['to'], $backup_path, true); //PEA: now copy backup
				/* END - RESTORE POINT - by MR. MILK August 31, 2005 02:22:18 PM */
					}
					$backup_path = clean_path( remove_file_extension(urldecode(hashToFile($_REQUEST['install_file'])))."-restore");
					if(file_exists($backup_path))
						rmdir_recursive($backup_path);
				}
	}
}

require_once('modules/Administration/QuickRepairAndRebuild.php');
require_once('include/utils/layout_utils.php');
class SpmRepairAndClear extends RepairAndClear
{
    public $sql;
    public $oneLine = true;
    public function repairDatabase()
    {
        global $dictionary, $mod_strings;
        $_REQUEST['repair_silent']=1;
        $_REQUEST['execute']=$this->execute;
        $GLOBALS['reload_vardefs'] = true;
        $hideModuleMenu = true;
        include_once('modules/Administration/repairDatabase.php');
        if(!empty($sql)) {
            $qry_str = "";
            foreach (explode("\n", $sql) as $line) {
                if($this->oneLine) {
                    if (!empty ($line) && substr($line, -2) != "*/") {
                        $qry_str .= $line.";";
                    }
                }
                else {
                    $qry_str .= $line;
                    if (!empty ($line) && substr($line, -2) != "*/") {
                        $qry_str .= ";";
                    }
                    $qry_str .= "\n";
                }
            }
            $this->sql = $qry_str;
        }
    }
}

try {
    $cmd->execute();
    $error = null;
}
catch (Exception $e) {
    echo $e->getMessage(),"\n";
    $error = true;
}
Spm::cleanupSugar();
if($error) {
    exit(1);
}
